{
  "name": "Lopper",
  "tagline": "A lightweight C++ framework for vectorizing image-processing code",
  "body": "Lopper\r\n======\r\n\r\nLopper is a lightweight C++ template meta-programming framework for making vectorizing image-processing code easy, synthesized during Dropbox's 2016 hack week. It was inspired by many (more general) predecessors like Eigen and Halide, but the core focus was in enabling precise control over inlining of primitive computation. It can target platforms that support SSE (4.2) or NEON instructions. Note that Lopper does some very naughty things, like placing variables on the stack without being explicit about it, so take care when using it.\r\n\r\nRequirements\r\n------------\r\n\r\nLopper consists only of C++ header files, so no pre-compilation is necessary. Simply include \"lopper/lopper.hpp\" and compile your code with C++11-standard-compliant compiler. You will need CMake to build the unit test.\r\n\r\nUsage\r\n-----\r\n\r\nThe code snippes below assume that `using namespace lopper` is in effect.\r\n\r\nImages can be wrapped into an expression as follows:\r\n```\r\nauto a = Expr<1>(image); // image must be a 1-channel image.\r\nauto rgb = ExprCache(Expr<3>(image)); // multi-channel images must first be wrapped by ExprCache.\r\nauto r = rgb.get<0>();\r\n```\r\n\r\nOne can combine expressions to form other expressions:\r\n```\r\nauto c = a + a * a;\r\nauto d = c + 3;\r\nauto e = c * d; // implicitly expand to (a + a * a) * ((a + a * a) + 3)\r\n...\r\n```\r\n\r\nIn general, every expression will be inlined during evaluation. In order to reuse values, use `ExprCache`; you must assign the resulting expression to a variable, owing to macro expansion that happens, and must first declare `ExprPrepareContext` as shown below, but it can be very powerful in controlling exactly what arithmetic happens in the evaluation.\r\n```\r\nExprPrepareContext();\r\nauto c = ExprCache(a + a * a);\r\nauto d = c + 3;\r\nauto e = c * d; // implicitly equivalent to c = a + a * a; e = c * (c + 3)\r\n...\r\n```\r\n\r\nTo trigger evaluation, use the `ExprEval` macro on an assignment operation if you haven't inlined anything:\r\n```\r\nauto a = Expr<1>(image1) + Expr<1>(image2);\r\nExprEval(Expr<1>(image3) = a * a);\r\n```\r\n\r\nOn the other hand, you must use `ExprEvalWithContext` macro otherwise:\r\n```\r\nExprPrepareContext();\r\nauto a = ExprCache(Expr<1>(image1) + Expr<1>(image2));\r\nExprEvalWithContext(Expr<1>(image3) = a * a);\r\n```\r\n\r\nLopper supports rudimentary index manipulation, without providing the full functional expansion (e.g. Halide). Any expression that's instantiated directly from a single-channel image can call `reindex` or `offset`.\r\n```\r\nExpr<1>(image1).offset(1, 0) - Expr<1>(image1); // expression for forward horizontal gradient\r\nExpr<1>(image1).reindex([](int y) { return image1.getHeight() - 1 - y; }); // expression for flipping the image vertically.\r\n```\r\n\r\nSee the unit tests for more examples.\r\n\r\nRequirements for Contributors\r\n-----------------------------\r\n\r\nIf you plan to contribute a patch, please read the Contributor License Agreement at https://opensource.dropbox.com/cla/.\r\n\r\nLicense\r\n-------\r\nLopper is offered under Apache License 2.0. Please see license.txt for details.\r\n\r\nContributors\r\n------------\r\nLopper was initially written by Jongmin Baek (jongmin@dropbox.com) with plenty of help and advice from Leonard Fink (leonard@dropbox.com), Lailin Chen (lailin@dropbox.com) and Ying Xiong (yxiong@dropbox.com).\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}